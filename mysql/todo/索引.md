# 1 索引模型

## 1.1哈希表

- **哈希表这种结构适用于只有等值查询的场景**，比如Memcached及其他一些NoSQL引擎
- 

## 1.2有序数组

- **有序数组在等值查询和范围查询场景中的性能就都非常优秀**
  - 用二分法就可以快速得到，这个时间复杂度是O(log(N))。
- 但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。
  - 所以，**有序数组索引只适用于静态存储引擎**，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据

## *1.3 搜索树

二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -> UserC -> UserF -> User2这个路径得到。这个时间复杂度是**O(log(N))**

当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，**更新的时间复杂度也是O(log(N))**

---

树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证**从左到右递增**。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，**还要写到磁盘上**

你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。

为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，**“N叉”树中的“N”取决于数据块的大小**

以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。

N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。



# 2 InnoDB 的索引模型

## 2.1 主键索引

## 2.2 非主键索引

- 在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。
- 每一个索引在InnoDB里面对应一棵B+树。

|              | 主键索引                    | 非主键索引                                                   |
| ------------ | --------------------------- | ------------------------------------------------------------ |
| 也被称为     | 聚簇索引（clustered index） | 二级索引（secondary index）                                  |
| 叶子节点存的 | 整行数据                    | 主键的值                                                     |
| 查询方式     | 只需要搜索ID这棵B+树        | 需要先搜索k索引树，得到ID的值为500，<br />再到ID索引树搜索一次。<br />这个过程称为回表。 |



# 3 索引维护

## 3.1 B+树插入新的行

- B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
- 而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
- 除了**性能**外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体**空间利用率**降低大约50%。
- 当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。



## 3.2 自增主键vs业务逻辑的字段做主键

- 由于每个非主键索引的叶子节点上都是主键的值。
  - **显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**