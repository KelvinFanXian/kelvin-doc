- [ref](https://www.homedt.net/380762.html)



# 软件架构风格可分为5大类

## 1 数据流风格

![image-20220802173323332](https://oss-kelvinvan.oss-cn-chengdu.aliyuncs.com/img/image-20220802173323332.png)

### 批处理序列

> （Batch Sequential）

- 组件为一系列固定顺序的计算单元，组件间只通过数据传递交互
- 每个处理步骤是一个独立的程序，每一步**必须在前一步结束**后才能开始
- 数据必须是完整的，以整体的方式传递

### 管道-过滤器

> （Pipes/Filters）

- 每一个构件都有一组输入和输出，构件读取输入的数据流
- 经过内部处理，然后产生输出的数据流。 禅修过程通常对输入流的变换及增量计算来完成，包括通过计算和增加信息丰富数据、通过浓缩和删除精炼数据，以及通过改变记录方式转化数据和递增转化数据等。**在输入被完全消费之前，输出便产生了**
- 这里构件被称为「过滤器」，连接件就是数据流传输的管道，将一个过滤器的输出传到另一个过滤器的输入



## 2 调用/返回风格

![image-20220802172709795](https://oss-kelvinvan.oss-cn-chengdu.aliyuncs.com/img/image-20220802172709795.png)

### 主程序/子程序

> （Main Program and Subroutine）

- 单线程控制，把问题划分为若干处理步骤。
- 构件即主程序和子程序，子程序通常可合成为模块。
- 过程调用作为交互机制，即充当连接件。
- 调用关系具有层次性，其语义逻辑表现为子程序的正确性

### 数据抽象和面向对象

> （Data Abstraction and Object-Oriented）

- 这种风格的构件是对象，对象是抽象数据类型的实例。
- 在抽象数据类型中，数据的表示和它们的相应操作被封装起来，对象的行为体现在其接受和请求的动作。
- 连接件即对象间交互的方式，对象是通过函数和过程的调用来交互的
- 它具有封装性，一个对象的改变不会影响其他对象
- 对象拥有状态和操作，也有责任维护状态。
- 这种结构风格中包含封装、交互、多态、集成和重用等特征

- 层次结构架构风格（Hierarchical Layers）
  - 层次系统组织成一个层次结构，构件在一些层实现了虚拟机
  - 连接件通过决定层间如何交互的协议来定义，拓扑约束包括对相邻层间交互的约束
  - 这个风格的特点是每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层
  - 在的问题分解为若干个渐进的小问题，逐步解决，隐藏了很多复杂度
  - 修改一层，最多影响两层，而通常只能影响上层
  - 上层必须知道下层的身份，不能调整层次之间的顺序



## 3 独立构建风格

![image-20221016131149038](https://oss-kelvinvan.oss-cn-chengdu.aliyuncs.com/img/image-20221016131149038.png)

### 进程通信架构风格

> （Communicating Processes）

- 构件是独立的过程，连接件是消息传递。
- 这种风格的特点是构件通常是命名过程，消息传递的方式可以是点对点、异步和同步方式，以及远过程调用等

### 事件驱动架构风格

> （Event Systems）

- 构件不直接调用一个过程，而是触发或广播一个或多个事件
- 系统中其他构件中的过程在一个或多个事件中注册，当一个事件被触发，系统自动调用在这个事件中注册的所有过程
- 一个事件的触发就导致了另一个模块中过程的调用
- 这种风格中的构件是非命名的过程，它们之间交互的连接件往往是以过程之间的隐式调用（Implicit Invocation）来实现的
- 基于事件的隐式调用风格的主要优点是为软件重用提供了强大的支持，并为构件的维护和演化带来了方便
- 其缺点是构件放弃了对系统计算的控制



## 4 虚拟机风格

### 解释器架构风格

> （Interpreters）

- 一个解释器通常包括完成解释工作的解释引擎、
- 一个包含将被解释的代码的存储区、
- 一个记录解释引擎当前工作状态的数据结构，以及一个记录源代码被解释执行进度的数据结构
- 具有解释器风格的软件中含有一台虚拟机，可以仿真硬件的执行过程和一些关键应用；
- 其缺点是执行效率较低

### 基于规则的系统架构风格

> （Rule-based Systems）

- 包括规则集、规则解释器、规则/数据选择器及工作内存

```bash
#解释器风格：当底层不支持上层时，在两者之间加入一层虚拟机做模拟仿真，消除硬件和软件之间的差异
优点：可以模拟原来不具有的功能，可以模拟一些灾难性的情况
缺点：效率太低，因为多了一层解释器
应用：各种脚本语言，配置文件，通信协议，用户输入等

#规则系统风格：根据既定的规则和目前的事实，做出相应的输出
特点：有需要被执行的代码，解释器，控制解释器的部分，存储当前状态的存储器

规则引擎和黑板系统有相似之处，都是存储规则和各种事实，计算机自动根据读入的状态，事实库和规则库执行相应的操作。但是，黑板系统是针对一个大而复杂的问题，对于这一个问题要用到多个规则和对策，侧重的是利用人工智能解决复杂问题。而规则引擎针对的是一系列不断输入的小问题，侧重于业务逻辑和代码分离
```







## 5 仓库风格

### 数据库架构风格

> （Database）

- 数据库架构是仓库风格最常见的形式，构件主要有两大类，
- 一个是中央共享数据源，保存当前系统的数据状态
- 另一个是多个独立处理元素，处理元素对数据元素进行操作

### 黑板架构风格

> （Black Boards）

- 黑板架构包括**知识源**、**黑板**和**控制**3个部分
- 知识源包括若干独立计算的不同单元，提供解决问题的知识。 它响应黑板上的变化，也只修改黑板；
- 黑板是一个全局数据库，包含解域的全部状态，是知识源互相作用的唯一媒介
- 知识源响应通过黑板状态的变化来控制，黑板架构风格通常应用在对于解决问题没有确定性算法的系统中，如 信号处理、问题规划及编译器优化等软件系统的设计中

### 超文本系统





# 其他架构风格

## 特定领域软件体系结构架构风格

> （Domain-Specific Software Architecture）



## 状态转移架构风格

> （State Transition System）



## 分布式处理架构风格

> （Distributed Process）

## 客户机/服务器（C/S）架构风格

## 浏览器/服务器（B/S）架构风格

## CORBA架构风格

## DCOM架构风格

## EJB架构风格

## REST混合架构风格

> （Representational State Transfer）











---

- 经典软件体系结构风格
  - **数据流风格**：批处理序列、管道-过滤器
  - **调用/返回风格**：主程序/子程序、面向对象、层次结构
  - **独立构件风格**：进程通信、事件驱动系统（隐式调用）
  - **虚拟机风格**：解释器、基于规则的系统
  - **仓库风格**：数据库系统、超文本系统、黑板系统
- C2风格
- 客户/服务器风格
- 三层C/S结构风格
- 浏览器/服务器风格
- 基于**层次**消息总线的体系结构风格
- 异构结构风格
- 互连系统构成的系统及其体系结构
- 互连系统构成的系统
- 基于SASIS的软件过程





